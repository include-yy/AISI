# 写个解释器

在本章，我会展示一个简单的 Scheme 子集解释器，它是用 Scheme 写的。

我会以一个相当简单的，Scheme 小子集的小解释器开始，它只能理解简单的算术表达式。

之后我会以多种方式对解释器进行改进。

在之后的章节中，我们会回到本章并加上宏 \[blah blah blah ...\]

### 1.[解释与编译](#1)

### 2.[实现简单解释器](#2)

### 3.[讨论和回顾](#3)

<h2 id = "1"> </h2>

### 1.解释和编译

编程语言通常通过解释器或编译器来实现，或是它们的混合。实际上，几乎所有的语言实现都是它们的混合，至少在一定程度上如此，而且两者的界限是令人惊奇地模糊。

一个纯的解释器读取程序的源文本，对它进行分析，并进行执行。这通常非常慢 —— 解释器用大量的时间分析字符串来弄清字符串的意义。一个纯解释器必须识别并分析它所碰到的源文本中的每一个表达式，以便它知道下一步怎么做。这也就是大多数命令行 shell 的工作方式，包括 UNIX shell 和 Tcl。

一个纯编译器读取程序的源文本，并将其翻译为能够执行程序的机器码。编译器的一大优点是它们能够一次性完成源程序的分析，并生成与通过解释器运行程序效果一致的代码。相比在每次遇到表达式时进行分析，编译器一次性完成分析过程，但会记录解释器在分析时应该完成的动作。

实际上，编译器是一种古怪（weird）的解释器，它“假装”解释程序，并记录下解释器会做的工作。它之后会浏览它记录的内容，并产出（spits out）和解释器效果相同的指令。大多数的解释期间做的决策 —— 比如判断表达式是赋值表达式，还是过程调用 —— 可以在编译期间完成，因为每次运行（同一个）程序时遇到的表达式是相同的。

编译器的工作就是完成总是相同的工作，并产完成工作的指令，这些指令将完成只能在运行时完成的”实际工作“，因为它取决于程序正在操作的实际数据。例如，`if` 语句在每次遇到时总是 `if` 语句，因此分析只需一次分析。但哪条分支被选取取决于表达式在运行时的值，因此编译器必须生成（emit）代码来测试表达式的值，并选择合适的分支。

大多数真实的解释器实际上是介于纯解释器和纯编译器之间的。它们一次性读取程序的源代码，并将其翻译成一种便于处理的”中间表示“ —— 某种类型的数据结构 —— 并在之后对它进行解释。相比于一步步分析源文本字符串，它们以一种更方便的方式来分析代表源文本的数据结构，这样操作起来速度快得多。也就是说，它们进行了一次分析，将源文本转化为一种数据结构，并在执行程序时一步步分析程序对应的数据结构。

下面列出了四条使用 Scheme 解释器作为 Scheme 示例程序的理由：

1. 一个简单的解释器真的很简单，但是它能够展示一些 Scheme 的方便特性。它是 Scheme 编程的好例子。

2. 大多数大型程序都包含一个某种程度的命令行解释器，因此每个程序源都应该知道如何写个像样的。通常，命令行解释器对系统的可用性和功能有巨大的影响，太多的程序的解释器都很烂。

3. 理解 Scheme 解释器的工作方式可能会同时弄清一些语言问题。它会给你带来对 Scheme 遇见表达式时的行为的具体的理解，因此你会知道你的程序将会做什么 —— 例如，你会明白你在什么时候会需要 引号（quote）或 括号（parentheses），什么时候又不需要。

4. 每个程序员都应该理解编译器工作的基础。理解一个 Scheme 解释器让你对 Scheme 编译器有个一知半解的了解。Scheme 编译器和 Scheme 解释器非常像 —— 它对 Scheme 表达式进行分析并弄清要做什么。两者的主要区别仅仅是在于，当解释器弄清工作后，它会立刻执行，但编译器会将工作记录下来，并在之后运行程序时执行。

<h2 id = "2"> </h2>

### 2.实现一个简单的解释器

在本节，我们会使用 Scheme 来实现一个 Scheme 的微小子集 —— 只是简单的算术表达式。这个解释器很简单，但它是个真正的解释器 —— 它的工作原理与许多真正的 Scheme 系统是一样的。在下一章中，我们会展示一个更加复杂的解释器，它实现了大多数重要的 Scheme 特性，而且实现了一个 Scheme 编译器的骨架（skeleton）。

解释器是个学习 Scheme 的不错例子，因为它重度依赖递归 —— 读取和求值的过程自然就是递归地。就像你将看到的，解释器代码也可作为函数式编程的例子（带一丁点的副作用）；以自然的方式使用递归避免了对副作用的需要，因为数据构造一般是在当前创造的，既不太早，也不是被更新的太迟。

我们的解释器会使用 Scheme 内置过程 `read` 来接收 S-表达式形式的输入，也即 Scheme 标准数据结构形式的表达式，比如 符号(symbol)，数字(number)，也可能是带有这些内容的嵌套表。\[记住这个\] S-表达式可以是简单的，就像符号，或是复杂的，就像嵌套的表。

#| 在下文中，我会用 REPL 这个简写来代替 读取-求值-打印 循环，也就是 Read-Eval-Print Loop |#

#### 2.1.[读取-求值-打印 循环](#2.1) the Read-Eval-Print Loop

#### 2.2.[读取器](#2.2) the Reader

#### 2.4.[A note on Snarfing and Bootstrapping](#2.4)

<h2 id = "2.1"> </h2>

#### 2.1.读取-求值-打印 循环

（如果你对 REPL 不感兴趣的话，你可以跳过这一小节，REPL 只是个作为求值器”前端“的命令行解释器。）

当你通过键入文本与 Scheme 进行交互时，你是在与 一个叫做 *read-eval-print* loop 的过程进行交互。这个过程循环着 接收命令，执行它，并打印结果的过程。

每次循环的三个步骤是：

1. 调用 `read` 来读入从键盘缓冲区输入的组成文本表达式的字符，并产生一个数据构造来表示它。

2. 调用 `eval` 来对表达式求值 —— 直观而言，`eval` ”找出表达式的意义“，并”按表达式说的去做“，返回表达式的值 —— 之后

3. 调用 `write` 来打印 `eval` 结果的文本表示，以便用户能够看到。

（更一般地，我们可能从文件中读取表达式，而不是从键盘缓冲区。我们现在先忽略这一点）

你可以为你自己的程序写出自己的 REPL，以便用户可以输入表达式，然后你以你想要的方式来进行解释。之后，我会展示如何编写求值器（evaluator），这将会派上用场。你可以从你的 REPL 开始（通过输入 `(rep-loop)` ），然后它会覆盖一般的 Scheme REPL，以你的方式解释表达式。

下面是一个非常简单的 REPL：

```scheme
(define (rep-loop)
   (display "repl>")      ; print a prompt
   (write (eval (read)))  ; read expr, pass to eval, write result
   (rep-loop))            ; loop (tail-recursive call) to do it again
```

（注意到，表达式 `(write (eval (read)))` 以合适的 读取-求值-打印 顺序来做事，因为每个过程调用的参数在调用实际发生之前会被计算。在 Scheme 中，也在大多数语言中，嵌套过程调用的执行顺序是”从里到外“。

我以递归的方式来表达迭代，而不是使用循环结构。这个过程是尾递归的，因为在它的最后，它所做的就是调用自身。记住，Scheme 对这类递归非常聪明，且从不会在堆栈上建立过程调用活跃（procedure activation）信息，从而导致堆栈溢出。你总是可以进行尾递归。因为在尾部调用后什么也没做， Scheme 能够避免对它的返回，并避免保留任何返回状态。

上面的 REPL 并不是非常友好，因为它并没有给你机会来退出无限循环。让我们对它进行调整来让你通过输入符号 halt 来退出循环。

```scheme
(define (rep-loop)
   (display "repl>")              ; print a prompt
   (let ((expr (read)))           ; read an expression, save it in expr
      (cond ((eq? expr 'halt      ; user asked to stop?
             (display "exiting read-eval-print" loop)
             (newline)
            (#t                   ; otherwise
             (write （eval expr)) ; evaluate and print
             (newline)
             (rep-loop)))))       ; and loop to do it again
```

注意到它仍然是尾递归的，因为进行递归调用的分支在之后什么也不做。

这个 REPL 还可以被小小的改进。通过使用符号 halt 作为命令来提示循环终止，我们阻止了人们将 halt 作为表达式求值。我们可以通过确保 halt 命令不会有语言中的任何表达式的语法来绕过这一点，但现在我们不必为此烦恼。

另一个改进是使在同一个 REPL 中使用不同的解释器成为可能。上面的 `rep-loop` 过程假设它会调用叫做 `eval` 的过程来对表达式求值。我们希望编写使用不同求值器的 `rep-loop` ，因此相比于直接使用 `eval` 的名字，我们可以将它作为参数来表明使用哪一个求值器。因为过程是一等的，我们可以传递一个指向求值过程的指针。

```scheme
(define (rep-loop our-eval)

   (display "repl>")                 ; print a prompt
   (let ((expr (read)))              ; read an expression, save it in expr
      (cond ((eq? expr 'exit)        ; user asked to stop?
             (display "exiting read-eval-print loop")
             (newline))
            (#t                      ; otherwise,
             (write (our-eval expr)) ;  evaluate and print

             (rep-loop our-eval))))) ;  and loop to do it again
;原文中，参数名为 evaluator，疑似笔误
```

这儿我只进行了三个改变。我加上了参数 `our-eval`, 它应该是一个过程。之后我将对 `eval` 的调用改为对 `our-eval` 的调用，也就是任意给定的求值器。之后我改变了对 `rep-loop` 的递归调用，将参数传递给下一个递归调用。

<h2 id = "2.2"> </h2>

#### 2.2.读取器

我们不会为我们的解释器写一个完整的读取器，但是我会描述读取器的工作方式，然后展示一个简化的读取器。

（我们的解释器将仅仅”欺骗” 我们所使用的 Scheme 系统的基础解释器，但最好知道我们如何写出读取器，这是递归编程的一个很好的例子。）

读取器就是过程 `read` ，它使用一些底层过程读取独立的字符并构建标记（tokens），`read` 将这些标记一起放进嵌套的数据构造。标记就是一个非常简单的物体，它没有嵌套结构。例如，表可以嵌套，但是符号不能，字符串不能，数字也不能。

`read` 使用的地城函数只是从输入（字符流）中读取单独的标记。这些标记包括符号，字符串，数字和括号。括号是特殊的，因为它们告诉读取器什么时候需要通过递归读取嵌套数据结构。

（我还没有介绍字符 I/O，不过别担心 —— Scheme 中存在一次读取一个字符过程，测试字符相等的过程，等等。就现在而言，我们会忽略这些细节，我会直接描述读取器的总体结构。）

让我们假设我们有一个能够读取符号，整数，字符串和（可能嵌套的）由这些东西组成的表。如何拓展它来读取其它东西是很清楚的。

#### 2.2.1.[实现 read](#2.2.1)

#### 2.2.2.[实现 read 过程](#2.2.2)

#### 2.2.3.[对读取器的评价](#2.2.3)

<h2 id = "2.2.1"> </h2>

#### 2.2.1.实现 read

`read` 使用递归来构建嵌套数据结构，在从左向右读入字符的时候。

例如，输入字符序列

(foo 20 (baz))

会被读取为一个三元素表，它的头两个元素是符号 `foo` 和数字 `20` ；它的第三个元素是另一个表，它的元素是符号 `bar` 。

`read` 也能够读入简单的东西，比如符号和数字。

由 `read` 构建的数据结构被称为 S-表达式。一个 S-表达式可以是像字符串和数字一样简单的东西，或是由 S-表达式构成的表。（注意这个递归定义覆盖了任意深度的表。）

（一般而言，S-表达式是由 Scheme 知道如何读取和写入的东西组成的树形结构（无环的）的数据结构，这些东西包括符号，数字，字符串和字符字面量，布尔值，由 S-表达式组成的表和向量。有时这个术语的范围甚至更加广泛，还包括任意的 Scheme 数据结构，但一般我们使用术语 S-表达式来指代拥有标准文本表示的东西，它可以被读取，用来创建一个数据构造。）

传统的术语 S-表达式非常不幸。技术上讲，表达式是程序的一部分，可以被求值产生 Scheme 值。

S-表达式 根本就不是表达式 —— 它是一种数据结构，它可以被作为程序中表达式的一种表示，也可以不。（例如，我们调用 `read` 来读取表 `(foo 20 (baz))` ，并在之后将这个表当作表用，而不是在程序中作为程序的一部分来进行解释）记住，读取器的工作只是将文本表达式转化为方便的数据结构，而不是将数据结构作为程序解释。实际上是求值器真正讲数据结构作为程序来解释，而不是读取器。这也就是为什么 REPL 将从 `read` 返回的 S-表达式 传递给`eval` 来进行求值。

我会展示一个有些过于简单的 `read` 版本，我叫它 `micro-read` 。主要的简化是 `micro-read` 只处理一些基础类型 —— 符号，非负整数和表 —— 我们已经省去了大多数错误检查的代码。我们假设我们正在读取一个合法的 Scheme 数据结构的文本表示。我们也没有处理来自文本而不是标准输入的读取，或是在到达文件结尾时如何处理。

为了使 `read` 的实现更加简单，我会使用叫做 `read-token` 的辅助过程，它每次读取一个标记。直观地，反复调用 `read-token` 会将输入切成一个一个“单词”。之后 `read` 能够将这些“单词”组合在一起形成“短语”，用来描述复杂的数据结构。

例如，下面的输入字符序列

(foo 1 (a "bar"))

会被切成下面的标记，每次一个，在从左到右的扫描输入中，通过反复调用 `read-token` 读取

( 

foo

1

(

a

"bar"

)

)

注意到，左括号和右括号也是标记，即使它们写作单字符。你可以将它们认作告诉 `read` 一个新的表从何处开始和结束的特殊单词。

考虑 `read-token` ，`read` 必须识别嵌套结构 —— 直观上看，当 `read-token` 识别单独的单词时，`read` 必须识别*短语* ，短语可能是嵌套的。每个短语与 `read` 必须构建的 S-表达式 相对应，嵌套的短语对应于嵌套的 S-表达式。
